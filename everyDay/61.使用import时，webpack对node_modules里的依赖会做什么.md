# Problem: 使用import时，webpack对node_modules里的依赖会做什么?

*[interview]: start

webpack里babel会将import语句转换成require，如果是符合相对路径的直接在相对路径里找，如果是符合npm包的那就从当前目录下的node_modules里找，并把依赖文件复制过来，往往是根据包的package.json的main或者module字段对应的路径，将文件里的内容复制到当前的bundle里，用一个闭包报起来，push到__webpack_module__数组里，有需要的时候用__webpack_require__函数去引用

## 当使用import导入某个模块时，Webpack会按照以下顺序来查找模块：

- 首先在当前项目的目录中查找该模块是否存在。
- 如果该模块不存在，则会在项目的node_modules目录中查找该模块是否存在。
- 如果该模块仍然不存在，则会继续向上级目录查找，直到找到该模块或者到达根目录为止。
- 如果在以上任意一级目录中找到该模块，则Webpack会将该模块打包到最终的输出文件中，以便在浏览器端使用。

需要注意的是，Webpack在查找模块时，会根据模块的package.json文件中的"**main**"字段来确定模块的入口文件。如果该字段不存在，则Webpack会默认使用该模块的index.js文件作为入口文件。

另外，当我们在项目中使用了许多第三方依赖库时，这些库通常会包含大量的代码和资源文件。为了减小打包后文件的大小，我们可以通过Webpack的配置来实现按需加载第三方库的功能，即只在需要使用某个库时才将该库打包进最终的输出文件中。这样可以大大减小最终的输出文件的大小，加快网页加载速度。

ES6 Module
不同于CommonJS和AMD的模块加载翻噶嘛，ES6在JS语言层面上实现了模块功能。它的设计思想是:尽量的静态化，使得编译时就能确定模块的依赖关系。在遇到模块加载命令import时，不会去执行模块，而是只生成一个引用。等到真的需要用到的时候，再到模块里面去取值。这和CommonJS模块规范的最大不同。

webpack会对node_modules里的依赖做什么
webpack会根据定义的引入方式判断模块类型，再进行相关编译转化。当使用import引入时，babel默认会把ES6的模块转化成CommonJS规范，然后会将node_module里的依赖打包成自执行函数的样式

(function(modules){
    //执行逻辑
})([模块数组])
在模块数组中将模块传入，在函数体中经过一系列操作最终将模块通过module.exports导出

### 关键词: bebel转换、逐级查找模块、根据package.json寻找入口文件
*[interview]: end
