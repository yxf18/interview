# Problem: 为什么 WeakMap 和 WeakSet 的键只能使用对象?在什么场景下使用?

*[interview]: start
WeakMap和WeakSet的键只能是对象，而不能是原始类型（如字符串、数字、布尔值）的原因是因为WeakMap和WeakSet的设计初衷是为了解决**对象引用的内存管理问题**。

在JavaScript中，对象是通过**引用来传递**和比较的，而原始类型是通过**值来传递和比较**的。WeakMap和WeakSet通过**使用弱引用的方式来管理对象**，即在没有其他引用存在时，垃圾回收机制可以自动回收被WeakMap和WeakSet引用的对象。这种机制有助于避免内存泄漏和减少不再需要的对象的占用。

由于WeakMap和WeakSet的键是弱引用，它们没有实际的对象引用，因此无法通过键来获取或比较值。它们的设计目的主要是用于构建附加数据或标记对象的数据结构。例如，在处理对象的缓存、临时数据存储或对象标记等场景下，WeakMap和WeakSet可以很好地应用。

下面是一些适合使用WeakMap和WeakSet的场景：

1. 对象附加数据：使用WeakMap来存储和管理与对象相关的附加数据。由于WeakMap的键是弱引用，当对象被垃圾回收时，附加数据也会被自动清除，避免了内存泄漏。

2. 对象标记：使用WeakSet来标记对象是否满足特定条件。例如，在处理事件订阅和观察者模式时，可以使用WeakSet来存储订阅者，当订阅者被垃圾回收时，自动取消订阅，避免不必要的内存消耗和资源泄漏。

3. 缓存管理：使用WeakMap来构建对象缓存，当缓存中的对象不再被引用时，自动从缓存中移除，节省内存和资源。

需要注意的是，由于WeakMap和WeakSet的键是弱引用，无法枚举和迭代，也无法获取其大小或元素列表。它们不适合用作存储需要遍历和操作的数据集合。同时，由于键是弱引用，必须确保在使用WeakMap和WeakSet时保留对键对象的引用，否则可能导致数据丢失。

总之，WeakMap和WeakSet提供了一种有效的方式来管理对象引用，避免内存泄漏和减少不再需要的对象的占用。它们在处理附加数据、对象标记和缓存管理等场景下非常有用。

## 关键词: 引用传递、垃圾回收、弱引用、自动回收、避免内存泄漏
*[interview]: end
