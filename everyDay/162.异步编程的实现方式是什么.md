# Problem: 异步编程的实现方式是什么?

*[interview]: start
## 常见的js异步解决方案有以下6种
1. callback
使用回调函数的方式有一个缺点是：多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护
2. promise
使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。
3. generator
它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来。
当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我们在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。
使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 **co 模块**等方式来实现 generator 的自动执行。
4. async/await
async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。
5. 事件监听 比如: addEventlistener
采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。
实现原理也是利用定时器的原理去把f1放入事件队列里，等全部执行完毕之后，才会执行事件队列里的方法
这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以"去耦合"（Decoupling），有利于实现模块化。
缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。
6. 发布订阅 比如: \$on \$emit
假定存在一个"信号中心"，某个任务执行完成，就向信号中心"发布"（publish）一个信号，其他任务可以向信号中心"订阅"（subscribe）这个信号，
从而知道什么时候自己可以开始执行。这就叫做"发布/订阅模式"（publish-subscribe pattern），又称"观察者模式"（observer pattern）。
这种方法的性质与"事件监听"类似，但是明显优于后者。因为我们可以通过查看"消息中心"，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。

## 关键词: callback、promise、async/await、generator、事件监听、发布订阅
*[interview]: end
