# Problem: 说一下你所了解的javascript的作用域链?

*[interview]: start

已知 JavaScript 代码执行一段可执行代码时，会创建对应的执行上下文。在创建执行上下文时，会创建作用域链(因为引用外部环境)

查找变量的时候，会先从当前上下文的环境记录中查找，如果没有找到，就会从上级执行上下文的环境记录中查找，一直找到全局上下文的环境记录。这样有多个执行上下文的环境记录构成的链表，就叫做作用域链。

**变量的作用域区别于 this 指针，变量作用域是静态的，在变量声明后就确定的，而 this 则是动态的，根据最后的调用情况判断；**

在 js 中，“全局变量”中指的是定义在所有函数之外的变量(也就是定义在全局代码中的变量)，与之相对的是“局部变量”，所指的是在某个函数中定义的变量。其中，函数内的代码可以访问自己上层函数的变量，也可以访问全局变量，这样就构成了作用域链。另外，隐式声明(没有使用 var 等语句)一个变量，该变量就会被默认为全局变量

## 原理
作用域链包含了执行环境有权访问的变量、函数的有序访问。它是一个有变量对象(VO/AO)组成的单项链表，主要用来进行变量查找。

js 内部有一个\[[scope]]属性，这个属性就是指向作用域链的顶端
```js
var val = "全局变量";
function handle(y) {
  var val = "局部变量";
  function s() {
    var z = 0;
    alert(val);
  }
  s();
}
handle(5); //局部变量
```
### 简单分析上面的流程：
全局执行环境：`[[scope]] ---> VO[handle,val] 只有全局VO,[[scope]]直接指向VO`。

函数 AA 执行环境：`[[scope]] ---> VO[y,s,val],首先全局VO压入栈，然后函数AA VO压入栈顶，[[scope]] 属性指向栈顶，变量、函数搜索就从栈顶开始`

函数 s 执行环境：`[[scope]]---> VO[[z], VO[y,s,val] VO[handle,val]],首先全局 VO 压入栈，然后依次 AA、s 压入栈，s 处于栈顶，[[scope]]属性直接指向 s 的 VO`

>应用场景：比如调用 s，进入 s 的执行环境，在执行 alert 的时候，首先会去查找 val 的声明，会先在作用域链的顶端查找，没查到就会沿着链继续往下查找，直到查找到就停止

# 总结
函数执行的时候，就将当前函数的VO放在链表开头，后面依次是上层函数，最后是全局对象。变量查找则依次从链表的顶端开始。js有个内部\[[scope]],这个属性包含了函数的作用域对象的集合，这个集合就称为函数的作用域链。它决定了哪些变量或者函数能在当前函数中被访问以及它的访问顺序

## 关键词: 静态作用域、动态this、\[[scope]]
*[interview]: end
