# Problem: React组件中怎么做事件代理？它的原理是什么？

*[interview]: start

React 基于 Virtual DOM 实现了一个 SyntheticEvent 层(合成事件层), 定义的事件处理器会接收到一个合成事件对象的实例, 它符合 W3C 标准, 且与原生的浏览器事件拥有同样的接口, 支持冒泡机制, 所有的事件都自动绑定在最外层上。

在 React 底层, 主要对合成事件做了两件事:

事件委派: React 会把所有的事件绑定到结构的最外层(document), `React会在内部维护一个映射表记录事件与组件事件处理函数的对应关系；`
当某个事件触发时，React根据这个内部映射表将事件分派给指定的事件处理函数；
当映射表中没有事件处理函数时，React不做任何操作；

自动绑定: React 组件中, 每个方法的上下文都会指向该组件的实例, 即**自动绑定 this 为当前组件**

所有的事件挂在**document**上，DOM事件触发后冒泡到document；React找到对应的组件，造出一个合成事件出来；并按组件树模拟一遍事件冒泡

React 中的事件分为 3 类。分别是 DiscreteEvent（离散事件），UserBlockingEvent（用户阻塞事件），ContinuousEvent（连续事件）。不同类型的事件代表了不同的优先级。
事件委托需要区分捕获和冒泡，有些事件由于没有冒泡过程，只能在捕获阶段进行事件委托。

### 注意： 16版本之前是 在document上  16+ 是在容器上(renderRoot的第二个参数)

## 思考：为什么要用合成事件
React 想实现一个全浏览器的框架， 为了实现这种目标就需要提供全浏览器一致性的事件系统，以此抹平不同浏览器的差异（提供合成事件对象，抹平浏览器的兼容性差异）

## 思考：合成事件与普通事件的差异
语法不同：事件名称，事件处理函数语法不同
阻止默认行为方式不同:
原生可以通过return false / e.preventDefault() 阻止默认行为
合成事件需要使用 e.preventDefault() ，return false 无效 (addEventListener)

## 思考：为什么react16之后要从根元素document转移到容器元素上
React16时事件委托的对象是 document，React17时事件委托的对象是容器组件
        这样做是有利于微前端的，微前端一个前端系统中可能有多个应用，

        如果继续采取全部绑定在document上，那么可能多应用下会出现问题。
React16时原生事件与React事件执行时，冒泡阶段与捕获阶段没有区分开（原生捕获-> 原生冒泡 -> React捕获 -> React冒泡）；React17时优化了合成事件的执行，当与原生事件一起调用时，捕获阶段总是先于冒泡阶段（React捕获 ->原生捕获 -> 原生冒泡 -> React冒泡）
react17废弃了事件池 

### 关键词： 合成事件、事件委托、事件冒泡、映射表

*[interview]: end
