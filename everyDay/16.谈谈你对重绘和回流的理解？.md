# Problem: 谈谈你对重绘和回流的理解？

\*[interview]: start

回流：浏览器 dom 元素的大小、位置、定位发生改变引起渲染引擎 重新生成 render tree
重绘：元素的颜色、透明度、背景的变化引起重新渲染。
**回流必重绘，重绘不一定会回流**

回流对于性能的消耗更大，要尽快能的避免。批量更新，更新元素设置 display：none/position:absolute/fixed 脱离文档流都可以进行优化

重绘和回流要从浏览器渲染机制说起:
浏览器是多进程多线程的，渲染过程如下:
网络进程拿到 html 页面 交给浏览器进程 浏览器进程的主线程开始执行渲染任务

1. 生成 DOM tree
2. 样式解析(style)(css 属性值计算过程)（可细说）
3. 根据前两个生成 layout tree（可能和 DOM tree）不一样（::伪元素）display none
4. paint 层级顺序确定
5. layer 图层生成然后拿着 layer+paint 去**合成器线程**,合成器线程分图块得到小的 tiles 给栅格线程，开启多个栅格线程堆图层**栅格化**，栅格线程栅格化得到 draw qurads 合成器线程将 draw qurads 图块信息给浏览器进程 浏览器进程给 GPU 进程，GPU 渲染

以上过程中如果你改动页面 DOM 的位置布局之类的信息就导致重排，把主线程里面那一堆从 dom 再走一遍

重绘是只改了颜色这种，只走 dom style paint

这个很耗性能所以要尽量避免 ，而且主线程还要跑 js 再把 react fibber 说了，transfrom 这个不占主线程

## 如何避免回流和重回

1. 减少访问 DOM 的次数：多次访问 DOM 的操作会导致多次回流和重绘，因此可以将多次访问 DOM 的操作合并成一次。

2. 避免频繁操作样式：频繁的改变元素的样式会导致多次回流和重绘，因此可以将样式的修改集中在一起，一次性修改。

3. 使用文档片段（DocumentFragment）：将多个节点一次性插入到 DOM 树中，可以减少回流次数。

4. 使用 CSS3 动画：使用 CSS3 动画可以避免使用 JavaScript 改变样式，从而减少回流次数。

## 总之，在开发 Web 应用程序时，应该尽量减少回流和重绘的次数，从而提高页面性能和用户体验。

一句话总结
回流（reflow）一定会引起重绘（repaint），重绘不一定引起回流

浏览器的渲染流程

解析 html，生成 om 树，

解析 css，生成 cssom 树

dom 树和 css 树结合，生成渲染数 render tree

回流：根据生成的 render tree，进行回流（layout），得到节点的几何信息（大小，位置）

重绘：根据 render tree 和回流得到的节点的几何信息，计算出节点的绝对像素，即他们在页面上的大小和位置

绘制：将像素发送给 GPU，展示在页面上。（这一步其实还有很多内容，比如会在 GPU 将多个合成层合并为同一个层，并展示在页面中。而 css3 硬件加速的原理则是新建合成层）

生成渲染树，浏览器做以下几件事 （渲染树只包含可见节点）

从 dom 根节点开始遍历每个可见的节点

对每个可见的节点，在 cssdom 中找到对应的规则，并应用

根据每个可见节点及其对应规则，生成渲染树

不可见的元素

不会渲染输出的节点：script、link、meta 等

通过 css 隐藏的节点：display:none，注意：利用 visibility 和 opacity 隐藏的节点还是在渲染树中

回流
根据渲染树，计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。

重绘
根据渲染树和回流，知道了哪些节点是可见的，以及可见节点的样式和具体几何位置和大小，，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。

发生回流的情况

添加或删除可见元素

元素位置发生变化

元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）

内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代

页面一开始渲染的时候（这肯定避免不了）

浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

浏览器的优化机制
大多数浏览器都会通过 队列化 修改并批量执行来优化重排过程
浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。

但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法：

offsetTop、offsetLeft、offsetWidth、offsetHeight
scrollTop、scrollLeft、scrollWidth、scrollHeight
clientTop、clientLeft、clientWidth、clientHeight
getComputedStyle()
getBoundingClientRect

减少回流和重绘
回流比重绘的代价高很多，如何避免

css

避免使用 table 布局（table 及其内部元素，他们可能需要多次计算，通常要花 3 倍于同等元素的时间）

尽可能在 DOM 树的最末端改变 class

避免设置多层内联样式

将动画效果应用到 position 属性为 absolute 或 fixed 的元素上（绝对定位已经脱离文档流了，不会影响到其他的元素，不会影响回流）

避免使用 CSS 表达式（例如：calc()）

触发 css3 硬件加速，不会触发回流重绘（GPU 加速），可以让 transform、opacity、filters 这些动画不会引起回流重绘

js

避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性

避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中

可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。因为 display：none 是不可见元素，不会引起回流

避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来

\*[interview]: end
