# Problem: 浏览器缓存机制(1)对于开发很重要，强缓存的内容能了解多少呢？

\*[interview]: start

缓存是一种非常重要的技术，可以想象下，一个网站每次都要请求非常多的资源，如果每次刷新都需要，重新向服务器请求一遍数据，这样服务器的压力就非常大，而且这种反复的请求是无意义的
下面从三个方面来说一下浏览器的缓存机制
1、强缓存
2、协商缓存
3、缓存位置

### 强缓存：

浏览器中的缓存分为两种，一种是需要发送 http 请求，一种是不需要发送请求。
首先是检查强缓存，这个阶段就不需要发送 http 请求

    如何来检查呢？是通过相应的字段来进行的
    在HTTP/1.0和HTTP/1.1中，这个字段是不一样的，在HTTP/1.0中，使用Expires,
    而在HTTP/1.1中，使用的是Cache-Control

    首先我们来看Expires：
    Expires即过期时间，存在于服务器返回的响应头中，告诉浏览器，在这个过期时间之前都可以从缓存中获取数据，无需再次请求
    但是这里面有一个坑：就是服务器的时间和浏览器的时间可能不一致，所以就导致服务器返回的这个过期时间可能是不准确的
    因此，在HTTP/1.1中就被抛弃了

    Cache-Control：
    跟Expires一样，也是存在于服务器返回的响应头中，他们的区别是，Cache-Control并没有采用具体的过期时间点，而是采用过期
    时长来控制缓存，对应的字段是max-age
    比如：Cache-Control:max-age=3600
    这就表示了，从服务器返回响应开始，3600秒内，浏览器都可以从缓存中获取数据
    此外，Cache-Control还有一些其他的属性
    public：客户端和代理服务器都可以缓存
    private：只有浏览器可以缓存，中间的代理服务器不能缓存
    no-cache：跳过强缓存，直接进入协商缓存
    no-state：不进行任何缓存
    s-maxage：只在代理服务器进行缓存

### 协商缓存：

当强缓存失效后，浏览器就会在请求头中携带相应的缓存 tag，来向服务器发送请求，然后服务器根据 tag 判断是否使用缓存。
协商缓存的 tag 分为两种：1、last-Modified 2、ETag 这两种 tag 各有优劣，不存在谁比谁更有优势

    last-Modified：（最后修改时间）
    在收到浏览器的第一次请求之后，服务器会在响应头中添加这个字段
    当浏览器再次向浏览器发送请求时，会在请求头中携带If-Modified-Since字段，值为从服务器传来的最后修改时间
    服务器拿到请求头中的If-Modified-Since后，会对比服务器中的资源的最后修改时间
    1、如果请求头中的时间小于服务器中的最后修改时间，说明是时候该更新了。然后返回新的资源
    2、否则返回304，告诉浏览器继续使用缓存

    ETag:
    ETag是服务器根据当前文件内容，生成的文件的唯一标识，当文件发生改变的时候，这个标识就会变，服务器会通过响应头，将
    这个数据传给浏览器

    浏览器再次向服务器发送请求时，会在请求头中携带if-None-Match，值为从服务器获取到的ETag

    当服务器获取到if-None-Match时，会对比服务器中该资源的ETag的值
    1、如果值不相等，证明该更新了，服务器会返回新的资源
    2、否则返回304，告诉浏览器继续使用缓存

    两者对比：
    精准度：ETag优于last-Modified，因为ETag是给资源上标识，所以能精准的感知到资源的变化，而last-Modified不能准确的
            感知资源的变化，主要表现在以下两方面
            1、只是编辑了资源，资源的内容并没有改变，这时候last-Modified缓存会失效
            2、last-Modified能感知的单位时间是秒，如果在一秒内修改了很多次，这时候last-Modified并没有体现出修改了
    性能：last-Modified要优于ETag，因为last-Modified只是记录了一个时间点，而ETag要根据文件的具体内容生成哈希值

    注意：如果两种方式都支持的话，服务器会优先考虑ETag

\*[interview]: end
