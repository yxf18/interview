# Problem: 说一下你所了解的react-fiber?

*[interview]: start

## 背景
react在进行组件渲染时，从setState开始到渲染完成整个过程是同步的。如果需要渲染的组件比较大，js执行会占据主线程时间较长，会导致页面响应效果变差，使react在动画、手势方面应用效果比较差

**页面卡顿**:Stack reconciler的工作流程像函数的调用过程。父组件调用子组件像是函数递归；对于庞大的dom树来说，recognition过程会很长，超过了**16.6ms**。在其期间，主线程是被js占用的，因此任何交互、布局、渲染都会停止，给用户的画面是页面被卡住了

## 原理

旧版React通过**递归**的方式来进行渲染，使用的是JS的函数执行栈，一直执行到空栈

fiber自己实现了组件调用栈，以**链表**的形式遍历组件树，可以灵活暂停，实现方式是利用了浏览器提供的**requestIdleCallback**APi，fiber其实就是一种数据结构，可以用一个纯JS对象来表示

React15架构可以分为两层：

- **Reconciler（协调器）**—— 负责找出变化的组件
- **Renderer（渲染器）**—— 负责将变化的组件渲染到页面上

为了实现不卡顿的效果，新增了一个**Scheduler(调度器)**来进行分配。优先级高的任务(键盘输入)可以打断优先级低的任务(diff)的执行，从而更快的生效。任务的优先级有六种：

可以将渲染工作分解成多个小任务，并且可以**中断和恢复渲染过程**。这意味着 React 可以更好地控制渲染优先级，提高应用的响应性和流畅性。

React Fiber 的实现基于一种称为“协作式调度”的算法，它可以基于**优先级**和**时间分片**等因素来调度渲染任务。React Fiber 还提供了一套新的 API，用于实现异步渲染和控制更新过程。

## 关键词: 16.6ms、递归、树、链表、Reconciler（协调器）、Renderer（渲染器）、Scheduler(调度器)、中断和恢复渲染、requestIdleCallback

*[interview]: end
